#!KAMAILIO
#
# VoIP Termination System - Kamailio Configuration
# Server: sw1.tellmetelecom.com (165.22.130.17)
# Version: 1.0.0
#

####### Defined Values #########

#!define DBURL "mysql://voip_user:LGf588IQwbz4LKBXkfpvcOwj@localhost/voip"
#!define LISTEN_IP "165.22.130.17"
#!define LISTEN_PORT 9060

# Enable features
#!define WITH_MYSQL
#!define WITH_REDIS
#!define WITH_ANTIFLOOD
#!define WITH_DEBUG

####### Global Parameters #########

# Debug level (0=off, 1=critical, 2=error, 3=warn, 4=info, 5=debug)
#!ifdef WITH_DEBUG
debug=4
log_stderror=no
#!else
debug=2
log_stderror=no
#!endif

memdbg=5
memlog=5

log_facility=LOG_LOCAL0
log_prefix="{$mt $hdr(CSeq) $ci} "

# Process settings
children=4
async_workers=4

# Network settings
listen=udp:LISTEN_IP:LISTEN_PORT
listen=tcp:LISTEN_IP:LISTEN_PORT
# Loopback for testing
listen=udp:127.0.0.1:9060

port=LISTEN_PORT

# Aliases
alias="sw1.tellmetelecom.com"

# Max limits
tcp_connection_lifetime=3600
tcp_max_connections=2048

# SIP message limits
maxbuffer=65536
max_while_loops=200

# DNS settings
dns=no
rev_dns=no
dns_try_ipv6=no

# User agent
user_agent_header="User-Agent: TellMeTelecom-SBC/1.0"
server_header="Server: TellMeTelecom-SBC/1.0"

####### Modules Section ########

mpath="/usr/lib/x86_64-linux-gnu/kamailio/modules/"

# Core modules
loadmodule "jsonrpcs.so"
loadmodule "kex.so"
loadmodule "corex.so"
loadmodule "tm.so"
loadmodule "tmx.so"
loadmodule "sl.so"
loadmodule "rr.so"
loadmodule "pv.so"
loadmodule "maxfwd.so"
loadmodule "textops.so"
loadmodule "siputils.so"
loadmodule "xlog.so"
loadmodule "sanity.so"
loadmodule "ctl.so"
loadmodule "cfg_rpc.so"
loadmodule "counters.so"

# Database modules
#!ifdef WITH_MYSQL
loadmodule "db_mysql.so"
#!endif

# Address/permissions modules
loadmodule "permissions.so"
loadmodule "htable.so"

# Dispatcher for load balancing/failover
loadmodule "dispatcher.so"

# SDP manipulation
loadmodule "sdpops.so"
loadmodule "textopsx.so"

# Routing helpers
loadmodule "rtimer.so"

# SIP trace
loadmodule "siptrace.so"

# Pike for flood protection
#!ifdef WITH_ANTIFLOOD
loadmodule "pike.so"
#!endif

# Redis
#!ifdef WITH_REDIS
loadmodule "ndb_redis.so"
#!endif

# JSON for API communication
loadmodule "jansson.so"

# Exec for scripts
loadmodule "exec.so"

# Statistics
loadmodule "statistics.so"

# Dialog for call tracking
loadmodule "dialog.so"

# SQL operations
loadmodule "sqlops.so"

####### Module Parameters ########

# ----- jsonrpcs params -----
modparam("jsonrpcs", "pretty_format", 1)
modparam("jsonrpcs", "fifo_name", "/run/kamailio/kamailio_rpc.fifo")
modparam("jsonrpcs", "dgram_socket", "/run/kamailio/kamailio_rpc.sock")

# ----- ctl params -----
modparam("ctl", "binrpc", "unix:/run/kamailio/kamailio_ctl")
modparam("ctl", "mode", 0660)
modparam("ctl", "user", "kamailio")
modparam("ctl", "group", "kamailio")

# ----- tm params -----
modparam("tm", "failure_reply_mode", 3)
modparam("tm", "fr_timer", 30000)
modparam("tm", "fr_inv_timer", 120000)
modparam("tm", "restart_fr_on_each_reply", 1)
modparam("tm", "cancel_b_method", 1)

# ----- rr params -----
modparam("rr", "enable_full_lr", 0)
modparam("rr", "append_fromtag", 0)

# ----- permissions params -----
modparam("permissions", "db_url", DBURL)
modparam("permissions", "address_table", "kamailio_address")

# ----- htable params -----
# Blacklist cache
modparam("htable", "htable", "blacklist=>size=8;autoexpire=3600")
# Customer IP cache
modparam("htable", "htable", "custip=>size=8;autoexpire=300")
# Active calls per customer
modparam("htable", "htable", "calls=>size=10;autoexpire=7200;initval=0")
# CPS tracking per customer
modparam("htable", "htable", "cps=>size=10;autoexpire=2;initval=0")
# Customer info cache
modparam("htable", "htable", "custinfo=>size=8;autoexpire=60")

# ----- dispatcher params -----
modparam("dispatcher", "db_url", DBURL)
modparam("dispatcher", "table_name", "kamailio_dispatcher")
modparam("dispatcher", "flags", 2)
modparam("dispatcher", "xavp_dst", "_dsdst_")
modparam("dispatcher", "xavp_dst_mode", 0)
modparam("dispatcher", "xavp_ctx", "_dsctx_")
modparam("dispatcher", "xavp_ctx_mode", 0)
modparam("dispatcher", "ds_ping_interval", 30)
modparam("dispatcher", "ds_ping_method", "OPTIONS")
modparam("dispatcher", "ds_probing_mode", 0)
modparam("dispatcher", "ds_ping_reply_codes", "class=2;code=480;code=404")

# ----- dialog params -----
modparam("dialog", "db_url", DBURL)
modparam("dialog", "db_mode", 0)
modparam("dialog", "track_cseq_updates", 1)

# ----- siptrace params -----
modparam("siptrace", "db_url", DBURL)
modparam("siptrace", "trace_on", 1)
modparam("siptrace", "trace_flag", 22)
modparam("siptrace", "trace_to_database", 1)
modparam("siptrace", "hep_mode_on", 0)
modparam("siptrace", "table", "sip_trace")

# ----- pike params -----
#!ifdef WITH_ANTIFLOOD
modparam("pike", "sampling_time_unit", 2)
modparam("pike", "reqs_density_per_unit", 30)
modparam("pike", "remove_latency", 4)
#!endif

# ----- ndb_redis params -----
#!ifdef WITH_REDIS
modparam("ndb_redis", "server", "name=redis;addr=127.0.0.1;port=6379;db=0")
#!endif

# ----- sqlops params -----
modparam("sqlops", "sqlcon", "voipdb=>mysql://voip_user:LGf588IQwbz4LKBXkfpvcOwj@localhost/voip")

####### Routing Logic ########

# Main request routing
request_route {
    # Per request initial checks
    route(REQINIT);

    # Check if this call has traces enabled (stored in Redis during INVITE)
    redis_cmd("redis", "GET voip:trace:$ci", "r_trace_check");
    if ($redis(r_trace_check=>value) != $null) {
        setflag(22);
        sip_trace();
    }

    # NAT detection (placeholder)
    route(NATDETECT);

    # CANCEL processing
    if (is_method("CANCEL")) {
        if (t_check_trans()) {
            route(RELAY);
        }
        exit;
    }

    # Handle retransmissions
    if (!is_method("ACK")) {
        if (t_precheck_trans()) {
            t_check_trans();
            exit;
        }
        t_check_trans();
    }

    # Handle requests within dialogs
    route(WITHINDLG);

    ### Only initial requests from here ###

    # Record route for dialogs
    if (is_method("INVITE|SUBSCRIBE")) {
        record_route();
    }

    # Account only INVITEs
    if (is_method("INVITE")) {
        setflag(4); # Dialog flag
        route(INVITE_PROCESS);
        exit;
    }

    # Handle OPTIONS
    if (is_method("OPTIONS")) {
        sl_send_reply("200", "OK");
        exit;
    }

    # Dispatch other methods
    route(RELAY);
}

# INVITE processing
route[INVITE_PROCESS] {
    # Check blacklist first
    route(CHECK_BLACKLIST);

    # Anti-flood check
    route(ANTIFLOOD);

    # Authenticate by IP
    route(AUTH_IP);

    # Check customer limits
    route(CHECK_LIMITS);

    # Process the call
    route(PROCESS_CALL);
}

# Request validation
route[REQINIT] {
    # Flood protection before anything
#!ifdef WITH_ANTIFLOOD
    if (src_ip != myself) {
        if ($sht(blacklist=>$si) != $null) {
            xlog("L_WARN", "BLOCKED - Blacklisted IP: $si\n");
            exit;
        }
        if (!pike_check_req()) {
            xlog("L_ALERT", "PIKE - Blocked: $rm from $fu (IP:$si:$sp)\n");
            # Add to temporary blacklist in Redis
            redis_cmd("redis", "SETEX voip:blocked:$si 3600 flood", "r");
            exit;
        }
    }
#!endif

    # Sanity checks
    if (!sanity_check("17895", "7")) {
        xlog("L_WARN", "SANITY - Malformed message from $si:$sp\n");
        exit;
    }

    # Max forwards check
    if (!mf_process_maxfwd_header("10")) {
        sl_send_reply("483", "Too Many Hops");
        exit;
    }

    # Check message size
    if (msg:len > 16384) {
        sl_send_reply("513", "Message Too Large");
        exit;
    }
}

# Check IP blacklist
route[CHECK_BLACKLIST] {
    # Check htable blacklist (loaded from DB)
    if ($sht(blacklist=>$si) != $null) {
        xlog("L_WARN", "BLACKLIST - Blocked IP from DB: $si\n");
        sl_send_reply("403", "Forbidden - Blacklisted");
        exit;
    }

    # Check Redis blacklist
    redis_cmd("redis", "GET voip:blocked:$si", "r");
    if ($redis(r=>value) != $null) {
        xlog("L_WARN", "BLACKLIST - Blocked IP from Redis: $si\n");
        sl_send_reply("403", "Forbidden - Blacklisted");
        exit;
    }
}

# Antiflood protection
route[ANTIFLOOD] {
#!ifdef WITH_ANTIFLOOD
    # Additional CPS check per IP
    $var(ip_cps_key) = "voip:ipcps:" + $si;
    redis_cmd("redis", "INCR $var(ip_cps_key)", "r");
    redis_cmd("redis", "EXPIRE $var(ip_cps_key) 1", "r2");

    if ($redis(r=>value) > 50) {
        xlog("L_ALERT", "FLOOD - IP $si exceeded 50 CPS\n");
        # Auto blacklist for 1 hour
        redis_cmd("redis", "SETEX voip:blocked:$si 3600 flood_cps", "r");

        # Insert alert
        sql_query("voipdb", "INSERT INTO alerts (uuid, type, severity, source_type, title, message, metadata) VALUES (UUID(), 'security_flood_detected', 'critical', 'system', 'Flood detected', 'IP $si blocked for flood (>50 CPS)', '{\"ip\": \"$si\"}')");

        sl_send_reply("503", "Service Unavailable - Rate Limited");
        exit;
    }
#!endif
}

# Authenticate by IP address
route[AUTH_IP] {
    # Check if source IP is authorized
    if (!allow_address(1, "$si", 5060)) {
        xlog("L_WARN", "AUTH - Unauthorized IP: $si for $ru\n");

        # Log the rejection
        sql_query("voipdb", "INSERT INTO audit_log (action, entity_type, ip_address, created_at) VALUES ('auth_rejected', 'customer', '$si', NOW())");

        # Track failed attempts
        redis_cmd("redis", "INCR voip:authfail:$si", "r");
        redis_cmd("redis", "EXPIRE voip:authfail:$si 600", "r2");

        if ($redis(r=>value) > 5) {
            xlog("L_ALERT", "AUTH - Multiple failures from $si, blocking\n");
            redis_cmd("redis", "SETEX voip:blocked:$si 3600 auth_fail", "r");
            sql_query("voipdb", "INSERT INTO ip_blacklist (ip_address, reason, source, attempts, expires_at) VALUES ('$si', 'Multiple auth failures', 'flood_detection', $redis(r=>value), DATE_ADD(NOW(), INTERVAL 1 HOUR)) ON DUPLICATE KEY UPDATE attempts = attempts + 1, expires_at = DATE_ADD(NOW(), INTERVAL 1 HOUR)");
        }

        sl_send_reply("403", "Forbidden - IP Not Authorized");
        exit;
    }

    # Get customer ID from IP (including force_cli)
    sql_query("voipdb", "SELECT c.id, c.uuid, c.name, c.max_channels, c.max_cps, c.max_daily_minutes, c.max_monthly_minutes, c.used_daily_minutes, c.used_monthly_minutes, c.traces_enabled, c.force_cli FROM customers c JOIN customer_ips ci ON c.id = ci.customer_id WHERE ci.ip_address = '$si' AND ci.active = 1 AND c.active = 1 LIMIT 1", "ra");

    if ($dbr(ra=>rows) == 0) {
        xlog("L_WARN", "AUTH - IP authorized but no customer found: $si\n");
        sl_send_reply("403", "Forbidden - Customer Not Found");
        exit;
    }

    # Store customer info in AVPs
    $avp(customer_id) = $dbr(ra=>[0,0]);
    $avp(customer_uuid) = $dbr(ra=>[0,1]);
    $avp(customer_name) = $dbr(ra=>[0,2]);
    $avp(max_channels) = $dbr(ra=>[0,3]);
    $avp(max_cps) = $dbr(ra=>[0,4]);
    $avp(max_daily_min) = $dbr(ra=>[0,5]);
    $avp(max_monthly_min) = $dbr(ra=>[0,6]);
    $avp(used_daily_min) = $dbr(ra=>[0,7]);
    $avp(used_monthly_min) = $dbr(ra=>[0,8]);
    $avp(traces_enabled) = $dbr(ra=>[0,9]);
    $avp(force_cli) = $dbr(ra=>[0,10]);

    xlog("L_INFO", "AUTH - Customer '$avp(customer_name)' (ID:$avp(customer_id)) from $si, force_cli=$avp(force_cli)\n");
}

# Check customer limits
route[CHECK_LIMITS] {
    # Check CPS limit
    $var(cps_key) = "voip:cps:" + $avp(customer_id);
    redis_cmd("redis", "INCR $var(cps_key)", "r");
    redis_cmd("redis", "EXPIRE $var(cps_key) 1", "r2");

    if ($redis(r=>value) > $avp(max_cps)) {
        xlog("L_WARN", "LIMIT - CPS exceeded for customer $avp(customer_id): $redis(r=>value)/$avp(max_cps)\n");

        # Generate alert if first occurrence in last minute
        redis_cmd("redis", "GET voip:alert:cps:$avp(customer_id)", "ra");
        if ($redis(ra=>value) == $null) {
            redis_cmd("redis", "SETEX voip:alert:cps:$avp(customer_id) 60 1", "ra2");
            sql_query("voipdb", "INSERT INTO alerts (uuid, type, severity, source_type, source_id, source_name, title, message) VALUES (UUID(), 'cps_exceeded', 'warning', 'customer', $avp(customer_id), '$avp(customer_name)', 'CPS limit exceeded', 'Customer $avp(customer_name) exceeded CPS limit: $redis(r=>value)/$avp(max_cps)')");
        }

        sl_send_reply("503", "Service Unavailable - CPS Limit Exceeded");
        exit;
    }

    # Check channels limit
    $var(calls_key) = "voip:calls:" + $avp(customer_id);
    redis_cmd("redis", "GET $var(calls_key)", "r");
    $var(active_calls) = $redis(r=>value);
    if ($var(active_calls) == $null) {
        $var(active_calls) = 0;
    }

    if ($var(active_calls) >= $avp(max_channels)) {
        xlog("L_WARN", "LIMIT - Channels exceeded for customer $avp(customer_id): $var(active_calls)/$avp(max_channels)\n");

        redis_cmd("redis", "GET voip:alert:chan:$avp(customer_id)", "ra");
        if ($redis(ra=>value) == $null) {
            redis_cmd("redis", "SETEX voip:alert:chan:$avp(customer_id) 60 1", "ra2");
            sql_query("voipdb", "INSERT INTO alerts (uuid, type, severity, source_type, source_id, source_name, title, message) VALUES (UUID(), 'channels_exceeded', 'warning', 'customer', $avp(customer_id), '$avp(customer_name)', 'Channels limit exceeded', 'Customer $avp(customer_name) at channel limit: $var(active_calls)/$avp(max_channels)')");
        }

        sl_send_reply("486", "Busy Here - Channel Limit Exceeded");
        exit;
    }

    # Check daily minutes limit
    if ($avp(max_daily_min) != $null && $avp(max_daily_min) > 0) {
        if ($avp(used_daily_min) >= $avp(max_daily_min)) {
            xlog("L_WARN", "LIMIT - Daily minutes exhausted for customer $avp(customer_id)\n");
            sl_send_reply("486", "Busy Here - Daily Minutes Exhausted");
            exit;
        }

        # Warning at 80%
        $var(daily_pct) = ($avp(used_daily_min) * 100) / $avp(max_daily_min);
        if ($var(daily_pct) >= 80) {
            redis_cmd("redis", "GET voip:alert:dmin:$avp(customer_id)", "ra");
            if ($redis(ra=>value) == $null) {
                redis_cmd("redis", "SETEX voip:alert:dmin:$avp(customer_id) 3600 1", "ra2");
                sql_query("voipdb", "INSERT INTO alerts (uuid, type, severity, source_type, source_id, source_name, title, message) VALUES (UUID(), 'minutes_warning', 'warning', 'customer', $avp(customer_id), '$avp(customer_name)', 'Daily minutes warning', 'Customer $avp(customer_name) at $var(daily_pct)% of daily minutes')");
            }
        }
    }

    # Check monthly minutes limit
    if ($avp(max_monthly_min) != $null && $avp(max_monthly_min) > 0) {
        if ($avp(used_monthly_min) >= $avp(max_monthly_min)) {
            xlog("L_WARN", "LIMIT - Monthly minutes exhausted for customer $avp(customer_id)\n");
            sl_send_reply("486", "Busy Here - Monthly Minutes Exhausted");
            exit;
        }
    }
}

# Process the call - select carrier and forward
route[PROCESS_CALL] {
    # Store original values
    $avp(caller_original) = $fU;
    $avp(callee_original) = $rU;

    # Capture User-Agent from INVITE
    $avp(user_agent) = $hdr(User-Agent);
    if ($avp(user_agent) == $null) {
        $avp(user_agent) = "Unknown";
    }

    xlog("L_INFO", "CALL - Processing: $fU -> $rU from customer $avp(customer_id) (UA: $avp(user_agent))\n");

    # Insert into active_calls with user_agent
    sql_query("voipdb", "INSERT INTO active_calls (call_id, customer_id, caller, callee, source_ip, start_time) VALUES ('$ci', $avp(customer_id), '$fU', '$rU', '$si', NOW(3))");

    # Increment call counter in Redis
    $var(calls_key) = "voip:calls:" + $avp(customer_id);
    redis_cmd("redis", "INCR $var(calls_key)", "r");
    redis_cmd("redis", "EXPIRE $var(calls_key) 7200", "r2");

    # Store start time in seconds for PDD calculation
    $avp(start_time) = $Ts;

    # Enable SIP traces if customer has it enabled OR always for troubleshooting
    if ($avp(traces_enabled) == 1) {
        setflag(22); # Trace flag
        # Store in Redis that this call has traces enabled (for BYE/ACK later)
        redis_cmd("redis", "SETEX voip:trace:$ci 7200 1", "r_trace");
        sip_trace();
    }

    # Select carrier using dispatcher
    # Algorithm 4 = round-robin (respects priority order via ds_use_priority)
    if (!ds_select_dst(1, 4)) {
        xlog("L_ERR", "CALL - No carriers available for $rU\n");

        # Enable trace for failed calls
        setflag(22);
        sip_trace();

        # Clean up
        sql_query("voipdb", "DELETE FROM active_calls WHERE call_id = '$ci'");
        redis_cmd("redis", "DECR $var(calls_key)", "r");

        sl_send_reply("503", "Service Unavailable - No Routes");
        exit;
    }

    # Get carrier ID from attrs
    $var(ds_attrs) = $xavp(_dsdst_=>attrs);
    $var(carrier_id) = $(var(ds_attrs){param.value,duid});
    $avp(carrier_id) = $var(carrier_id);

    xlog("L_INFO", "CALL - Selected carrier $avp(carrier_id) -> $du\n");

    # Force loopback socket for loopback destinations
    if ($dd =~ "^127\.") {
        xlog("L_INFO", "CALL - Using loopback socket for destination $du\n");
        force_send_socket(udp:127.0.0.1:9060);
    }

    # Get carrier config including prefix filters
    sql_query("voipdb", "SELECT tech_prefix, strip_digits, codecs, prefix_filter, prefix_deny FROM carriers WHERE id = $avp(carrier_id)", "rc");

    if ($dbr(rc=>rows) > 0) {
        $avp(tech_prefix) = $dbr(rc=>[0,0]);
        $avp(strip_digits) = $dbr(rc=>[0,1]);
        $avp(carrier_codecs) = $dbr(rc=>[0,2]);
        $avp(prefix_filter) = $dbr(rc=>[0,3]);
        $avp(prefix_deny) = $dbr(rc=>[0,4]);

        xlog("L_INFO", "CALL - Carrier config loaded: tech_prefix=$avp(tech_prefix), strip=$avp(strip_digits), codecs=$avp(carrier_codecs)\n");

        # Check prefix_deny first (blocked prefixes) - uses SQL LIKE matching
        if ($avp(prefix_deny) != $null && $avp(prefix_deny) != "") {
            # Query to check if callee matches any denied prefix
            sql_query("voipdb", "SELECT 1 FROM (SELECT TRIM(SUBSTRING_INDEX(SUBSTRING_INDEX('$avp(prefix_deny)', ',', n.n), ',', -1)) AS prefix FROM (SELECT 1 AS n UNION SELECT 2 UNION SELECT 3 UNION SELECT 4 UNION SELECT 5 UNION SELECT 6 UNION SELECT 7 UNION SELECT 8 UNION SELECT 9 UNION SELECT 10) n WHERE n.n <= 1 + LENGTH('$avp(prefix_deny)') - LENGTH(REPLACE('$avp(prefix_deny)', ',', ''))) prefixes WHERE '$rU' LIKE CONCAT(REPLACE(prefix, '*', '%'), '%') LIMIT 1", "r_deny");
            if ($dbr(r_deny=>rows) > 0) {
                xlog("L_WARN", "CALL - Destination $rU blocked by prefix_deny on carrier $avp(carrier_id)\n");
                # Try next carrier
                if (ds_next_dst()) {
                    $var(ds_attrs) = $xavp(_dsdst_=>attrs);
                    $var(carrier_id) = $(var(ds_attrs){param.value,duid});
                    $avp(carrier_id) = $var(carrier_id);
                    xlog("L_INFO", "CALL - Trying next carrier $avp(carrier_id) due to prefix_deny\n");
                    sql_query("voipdb", "SELECT tech_prefix, strip_digits, codecs, prefix_filter, prefix_deny FROM carriers WHERE id = $avp(carrier_id)", "rc");
                } else {
                    sql_query("voipdb", "DELETE FROM active_calls WHERE call_id = '$ci'");
                    redis_cmd("redis", "DECR $var(calls_key)", "r");
                    sl_send_reply("404", "Not Found - Destination Blocked");
                    exit;
                }
            }
        }

        # Check prefix_filter (allowed prefixes - if set, ONLY these are allowed)
        if ($avp(prefix_filter) != $null && $avp(prefix_filter) != "") {
            # Query to check if callee matches any allowed prefix
            sql_query("voipdb", "SELECT 1 FROM (SELECT TRIM(SUBSTRING_INDEX(SUBSTRING_INDEX('$avp(prefix_filter)', ',', n.n), ',', -1)) AS prefix FROM (SELECT 1 AS n UNION SELECT 2 UNION SELECT 3 UNION SELECT 4 UNION SELECT 5 UNION SELECT 6 UNION SELECT 7 UNION SELECT 8 UNION SELECT 9 UNION SELECT 10) n WHERE n.n <= 1 + LENGTH('$avp(prefix_filter)') - LENGTH(REPLACE('$avp(prefix_filter)', ',', ''))) prefixes WHERE '$rU' LIKE CONCAT(REPLACE(prefix, '*', '%'), '%') LIMIT 1", "r_filter");
            if ($dbr(r_filter=>rows) == 0) {
                xlog("L_WARN", "CALL - Destination $rU not in prefix_filter for carrier $avp(carrier_id)\n");
                # Try next carrier
                if (ds_next_dst()) {
                    $var(ds_attrs) = $xavp(_dsdst_=>attrs);
                    $var(carrier_id) = $(var(ds_attrs){param.value,duid});
                    $avp(carrier_id) = $var(carrier_id);
                    xlog("L_INFO", "CALL - Trying next carrier $avp(carrier_id) due to prefix_filter\n");
                    sql_query("voipdb", "SELECT tech_prefix, strip_digits, codecs, prefix_filter, prefix_deny FROM carriers WHERE id = $avp(carrier_id)", "rc");
                } else {
                    sql_query("voipdb", "DELETE FROM active_calls WHERE call_id = '$ci'");
                    redis_cmd("redis", "DECR $var(calls_key)", "r");
                    sl_send_reply("404", "Not Found - No Route for Destination");
                    exit;
                }
            }
        }

        # Apply strip digits (convert to integer variable first)
        $var(strip) = (int)$avp(strip_digits);
        if ($var(strip) > 0) {
            $rU = $(rU{s.substr,$var(strip),0});
            $tU = $(tU{s.substr,$var(strip),0});
            xlog("L_DBG", "CALL - Stripped $var(strip) digits, callee now: $rU\n");
        }

        # Apply tech prefix to both Request-URI and To header
        xlog("L_INFO", "CALL - tech_prefix check: avp=$avp(tech_prefix), rU=$rU\n");
        if ($avp(tech_prefix) != $null && $avp(tech_prefix) != "") {
            $rU = $avp(tech_prefix) + $rU;
            $tU = $avp(tech_prefix) + $tU;
            xlog("L_INFO", "CALL - Added tech_prefix, callee now: $rU (To: $tU)\n");
        }

        # Apply force_cli if configured for customer
        if ($avp(force_cli) != $null && $avp(force_cli) != "") {
            xlog("L_INFO", "CALL - Applying force_cli: $fU -> $avp(force_cli)\n");
            $fU = $avp(force_cli);
        }

        # Manipulate SDP codecs if specified
        if ($avp(carrier_codecs) != $null && $avp(carrier_codecs) != "") {
            # Remove all codecs except the ones specified by carrier
            xlog("L_DBG", "CALL - Carrier codecs: $avp(carrier_codecs)\n");

            # Remove codecs not in carrier's list
            if (!($avp(carrier_codecs) =~ "G729")) {
                sdp_remove_codecs_by_name("G729");
            }
            if (!($avp(carrier_codecs) =~ "PCMA")) {
                sdp_remove_codecs_by_name("PCMA");
            }
            if (!($avp(carrier_codecs) =~ "PCMU")) {
                sdp_remove_codecs_by_name("PCMU");
            }
            if (!($avp(carrier_codecs) =~ "GSM")) {
                sdp_remove_codecs_by_name("GSM");
            }
            if (!($avp(carrier_codecs) =~ "G722")) {
                sdp_remove_codecs_by_name("G722");
            }
            if (!($avp(carrier_codecs) =~ "OPUS")) {
                sdp_remove_codecs_by_name("opus");
            }
        }
    }

    # Update active_calls with carrier info
    sql_query("voipdb", "UPDATE active_calls SET carrier_id = $avp(carrier_id) WHERE call_id = '$ci'");

    # Store carrier call counter
    $var(carrier_calls_key) = "voip:carrier_calls:" + $avp(carrier_id);
    redis_cmd("redis", "INCR $var(carrier_calls_key)", "r");
    redis_cmd("redis", "EXPIRE $var(carrier_calls_key) 7200", "r2");

    # Store offered codecs in Redis for later CDR
    if (sdp_get_line_startswith("$avp(sdp_codecs)", "m=audio")) {
        redis_cmd("redis", "SETEX voip:codecs:$ci 7200 $avp(sdp_codecs)", "r");
    }

    # Store user_agent in Redis for later CDR
    redis_cmd("redis", "SETEX voip:ua:$ci 7200 $avp(user_agent)", "r");

    # Set failure route
    t_on_failure("MANAGE_FAILURE");
    t_on_reply("MANAGE_REPLY");
    t_on_branch("MANAGE_BRANCH");

    route(RELAY);
}

# Relay the request
route[RELAY] {
    if (is_method("INVITE|BYE|UPDATE|CANCEL")) {
        if (!t_is_set("branch_route")) {
            t_on_branch("MANAGE_BRANCH");
        }
    }

    if (is_method("INVITE|BYE|SUBSCRIBE|UPDATE")) {
        if (!t_is_set("onreply_route")) {
            t_on_reply("MANAGE_REPLY");
        }
    }

    if (is_method("INVITE")) {
        if (!t_is_set("failure_route")) {
            t_on_failure("MANAGE_FAILURE");
        }
    }

    if (!t_relay()) {
        sl_reply_error();
    }
    exit;
}

# Within dialog requests
route[WITHINDLG] {
    if (!has_totag()) {
        return;
    }

    if (loose_route()) {
        if (is_method("BYE")) {
            route(HANDLE_BYE);
        }
        if (is_method("ACK")) {
            route(NATMANAGE);
        }
        route(RELAY);
        exit;
    }

    # Handle BYE even without loose_route (e.g., when Route headers are missing)
    # This can happen with some SIP clients that don't properly handle Record-Route
    if (is_method("BYE")) {
        xlog("L_INFO", "BYE received without Route headers for call $ci\n");

        # Check if this call exists in our active_calls table
        sql_query("voipdb", "SELECT id FROM active_calls WHERE call_id = '$ci'", "r_check");

        if ($dbr(r_check=>rows) > 0) {
            # Call exists, process the BYE
            route(HANDLE_BYE);

            # Send 200 OK to the BYE
            sl_send_reply("200", "OK");
            exit;
        } else {
            xlog("L_WARN", "BYE for unknown call $ci\n");
        }
    }

    if (is_method("ACK")) {
        if (t_check_trans()) {
            route(RELAY);
            exit;
        }
        exit;
    }

    sl_send_reply("404", "Not Found");
    exit;
}

# Handle BYE - end of call accounting
route[HANDLE_BYE] {
    xlog("L_INFO", "BYE - Call $ci ending\n");

    # Trace BYE - check flag first, then Redis as fallback
    if (isflagset(22)) {
        sip_trace();
    } else {
        redis_cmd("redis", "GET voip:trace:$ci", "r_trace_bye");
        if ($redis(r_trace_bye=>value) != $null) {
            sip_trace();
        }
    }

    # Get call info from active_calls
    sql_query("voipdb", "SELECT customer_id, carrier_id, caller, callee, source_ip, start_time, answered, answer_time FROM active_calls WHERE call_id = '$ci'", "rb");

    if ($dbr(rb=>rows) > 0) {
        $var(cust_id) = $dbr(rb=>[0,0]);
        $var(carr_id) = $dbr(rb=>[0,1]);
        $var(caller) = $dbr(rb=>[0,2]);
        $var(callee) = $dbr(rb=>[0,3]);
        $var(src_ip) = $dbr(rb=>[0,4]);
        $var(start_time) = $dbr(rb=>[0,5]);
        $var(answered) = $dbr(rb=>[0,6]);
        $var(answer_time) = $dbr(rb=>[0,7]);

        # Get PDD, codec, and user_agent from Redis
        redis_cmd("redis", "GET voip:pdd:$ci", "r_pdd");
        $var(pdd) = $redis(r_pdd=>value);
        if ($var(pdd) == $null) { $var(pdd) = 0; }

        redis_cmd("redis", "GET voip:codec:$ci", "r_codec");
        $var(codec_used) = $redis(r_codec=>value);
        if ($var(codec_used) == $null) { $var(codec_used) = ""; }

        redis_cmd("redis", "GET voip:ua:$ci", "r_ua");
        $var(user_agent) = $redis(r_ua=>value);
        if ($var(user_agent) == $null) { $var(user_agent) = $avp(user_agent); }
        if ($var(user_agent) == $null) { $var(user_agent) = "Unknown"; }

        redis_cmd("redis", "GET voip:codecs:$ci", "r_offered");
        $var(codecs_offered) = $redis(r_offered=>value);
        if ($var(codecs_offered) == $null) { $var(codecs_offered) = ""; }

        # Calculate duration
        $var(duration) = $Ts - $TV(s);
        if ($var(duration) < 0) {
            $var(duration) = 0;
        }

        # Insert CDR with all fields
        # Note: sqlops returns datetime as Unix timestamps, so use FROM_UNIXTIME()
        if ($var(answered) == 1) {
            sql_query("voipdb", "INSERT INTO cdrs (uuid, call_id, customer_id, carrier_id, source_ip, caller, caller_original, callee, callee_original, start_time, answer_time, end_time, duration, billable_duration, pdd, sip_code, sip_reason, hangup_cause, user_agent, codec_used, codecs_offered) VALUES (UUID(), '$ci', $var(cust_id), $var(carr_id), '$var(src_ip)', '$var(caller)', NULLIF('$avp(caller_original)', '<null>'), '$var(callee)', NULLIF('$avp(callee_original)', '<null>'), FROM_UNIXTIME($var(start_time)), FROM_UNIXTIME($var(answer_time)), NOW(3), TIMESTAMPDIFF(SECOND, FROM_UNIXTIME($var(answer_time)), NOW()), TIMESTAMPDIFF(SECOND, FROM_UNIXTIME($var(answer_time)), NOW()), $var(pdd), 200, 'OK', 'caller', '$var(user_agent)', '$var(codec_used)', '$var(codecs_offered)')");

            # Update customer minutes
            $var(billable_min) = $var(duration) / 60;
            if ($var(billable_min) < 1 && $var(duration) > 0) {
                $var(billable_min) = 1;
            }
            sql_query("voipdb", "UPDATE customers SET used_daily_minutes = used_daily_minutes + $var(billable_min), used_monthly_minutes = used_monthly_minutes + $var(billable_min) WHERE id = $var(cust_id)");
        } else {
            # Failed call - still capture available data
            sql_query("voipdb", "INSERT INTO cdrs (uuid, call_id, customer_id, carrier_id, source_ip, caller, caller_original, callee, callee_original, start_time, end_time, duration, pdd, sip_code, sip_reason, hangup_cause, user_agent, codecs_offered) VALUES (UUID(), '$ci', $var(cust_id), $var(carr_id), '$var(src_ip)', '$var(caller)', NULLIF('$avp(caller_original)', '<null>'), '$var(callee)', NULLIF('$avp(callee_original)', '<null>'), FROM_UNIXTIME($var(start_time)), NOW(3), 0, $var(pdd), 487, 'Request Terminated', 'caller', '$var(user_agent)', '$var(codecs_offered)')");
        }

        # Delete from active_calls
        sql_query("voipdb", "DELETE FROM active_calls WHERE call_id = '$ci'");

        # Decrement Redis counters
        $var(calls_key) = "voip:calls:" + $var(cust_id);
        redis_cmd("redis", "DECR $var(calls_key)", "r");

        if ($var(carr_id) != $null) {
            $var(carrier_calls_key) = "voip:carrier_calls:" + $var(carr_id);
            redis_cmd("redis", "DECR $var(carrier_calls_key)", "r");
        }

        # Clean up Redis keys for this call (including trace flag)
        redis_cmd("redis", "DEL voip:pdd:$ci voip:codec:$ci voip:ua:$ci voip:codecs:$ci voip:trace:$ci", "r_del");
    }
}

# NAT detection placeholder
route[NATDETECT] {
    return;
}

# NAT management placeholder
route[NATMANAGE] {
    return;
}

# Branch management
branch_route[MANAGE_BRANCH] {
    xlog("L_DBG", "BRANCH - New branch [$T_branch_idx] to $ru\n");
}

# Reply management
onreply_route[MANAGE_REPLY] {
    xlog("L_DBG", "REPLY - $rs $rr for $ci\n");

    # Trace replies - check flag first, then Redis as fallback
    if (isflagset(22)) {
        sip_trace();
    } else {
        redis_cmd("redis", "GET voip:trace:$ci", "r_trace_reply");
        if ($redis(r_trace_reply=>value) != $null) {
            sip_trace();
        }
    }

    # Update on provisional responses (180 Ringing, 183 Progress)
    if (status=~"18[0-3]") {
        # Calculate PDD (Post Dial Delay) in milliseconds
        $var(pdd) = ($Ts - $avp(start_time)) * 1000;
        if ($var(pdd) < 0) {
            $var(pdd) = 0;
        }

        xlog("L_INFO", "REPLY - Progress $rs for $ci, PDD: $var(pdd) ms\n");

        # Store PDD in Redis for CDR
        redis_cmd("redis", "SETNX voip:pdd:$ci $var(pdd)", "r");
        redis_cmd("redis", "EXPIRE voip:pdd:$ci 7200", "r2");

        # Update active_calls with progress time
        sql_query("voipdb", "UPDATE active_calls SET answered = 0 WHERE call_id = '$ci' AND answered = 0");
    }

    # Update on 200 OK (answered)
    if (status=="200") {
        # Detect codec from 200 OK SDP using sdp_with_codecs
        $var(codec_used) = "unknown";
        if (sdp_with_codecs_by_name("G729")) {
            $var(codec_used) = "G729";
        } else if (sdp_with_codecs_by_name("PCMA")) {
            $var(codec_used) = "PCMA";
        } else if (sdp_with_codecs_by_name("PCMU")) {
            $var(codec_used) = "PCMU";
        } else if (sdp_with_codecs_by_name("G722")) {
            $var(codec_used) = "G722";
        } else if (sdp_with_codecs_by_name("GSM")) {
            $var(codec_used) = "GSM";
        }

        # Store codec in Redis for CDR
        redis_cmd("redis", "SETEX voip:codec:$ci 7200 $var(codec_used)", "r");

        sql_query("voipdb", "UPDATE active_calls SET answered = 1, answer_time = NOW(3) WHERE call_id = '$ci'");
        xlog("L_INFO", "REPLY - Call $ci answered (codec: $var(codec_used))\n");
    }
}

# Failure management
failure_route[MANAGE_FAILURE] {
    # Enable SIP trace for failed calls
    setflag(22);
    sip_trace();

    # Handle cancelled calls - create CDR but don't retry
    if (t_is_canceled()) {
        xlog("L_INFO", "FAILURE - Call cancelled by caller for $ci\n");

        # Create CDR for cancelled call
        sql_query("voipdb", "SELECT customer_id, carrier_id, caller, callee, source_ip, start_time FROM active_calls WHERE call_id = '$ci'", "rc");

        if ($dbr(rc=>rows) > 0) {
            $var(cust_id) = $dbr(rc=>[0,0]);
            $var(carr_id) = $dbr(rc=>[0,1]);
            $var(caller) = $dbr(rc=>[0,2]);
            $var(callee) = $dbr(rc=>[0,3]);
            $var(src_ip) = $dbr(rc=>[0,4]);
            $var(start_time) = $dbr(rc=>[0,5]);

            redis_cmd("redis", "GET voip:pdd:$ci", "r_pdd");
            $var(pdd) = $redis(r_pdd=>value);
            if ($var(pdd) == $null) { $var(pdd) = 0; }

            redis_cmd("redis", "GET voip:ua:$ci", "r_ua");
            $var(user_agent) = $redis(r_ua=>value);
            if ($var(user_agent) == $null) { $var(user_agent) = "Unknown"; }

            sql_query("voipdb", "INSERT INTO cdrs (uuid, call_id, customer_id, carrier_id, source_ip, caller, caller_original, callee, callee_original, start_time, end_time, duration, pdd, sip_code, sip_reason, hangup_cause, user_agent) VALUES (UUID(), '$ci', $var(cust_id), $var(carr_id), '$var(src_ip)', '$var(caller)', NULLIF('$avp(caller_original)', '<null>'), '$var(callee)', NULLIF('$avp(callee_original)', '<null>'), FROM_UNIXTIME($var(start_time)), NOW(3), 0, $var(pdd), 487, 'Request Terminated', 'caller', '$var(user_agent)')");

            sql_query("voipdb", "DELETE FROM active_calls WHERE call_id = '$ci'");

            $var(calls_key) = "voip:calls:" + $var(cust_id);
            redis_cmd("redis", "DECR $var(calls_key)", "r");

            if ($var(carr_id) != $null) {
                $var(carrier_calls_key) = "voip:carrier_calls:" + $var(carr_id);
                redis_cmd("redis", "DECR $var(carrier_calls_key)", "r");
            }

            redis_cmd("redis", "DEL voip:pdd:$ci voip:codec:$ci voip:ua:$ci voip:codecs:$ci voip:trace:$ci", "r_del");
        }
        exit;
    }

    xlog("L_INFO", "FAILURE - $rs $rr for $ci, attempting failover\n");

    # Try next carrier on certain failures (4xx, 5xx, 6xx)
    if (t_check_status("4[0-9][0-9]|5[0-9][0-9]|6[0-9][0-9]")) {
        # Update carrier failover count
        if ($avp(carrier_id) != $null) {
            sql_query("voipdb", "UPDATE carriers SET failover_count = failover_count + 1, daily_failed = daily_failed + 1 WHERE id = $avp(carrier_id)");
        }

        # Try next destination
        if (ds_next_dst()) {
            $var(ds_attrs) = $xavp(_dsdst_=>attrs);
            $var(new_carrier_id) = $(var(ds_attrs){param.value,duid});
            $avp(carrier_id) = $var(new_carrier_id);
            xlog("L_INFO", "FAILURE - Trying next carrier $avp(carrier_id)\n");

            sql_query("voipdb", "UPDATE active_calls SET carrier_id = $avp(carrier_id) WHERE call_id = '$ci'");

            t_on_failure("MANAGE_FAILURE");
            route(RELAY);
            exit;
        }

        xlog("L_WARN", "FAILURE - No more carriers for $ci\n");
    }

    # Create CDR for failed call
    sql_query("voipdb", "SELECT customer_id, carrier_id, caller, callee, source_ip, start_time FROM active_calls WHERE call_id = '$ci'", "rf");

    if ($dbr(rf=>rows) > 0) {
        $var(cust_id) = $dbr(rf=>[0,0]);
        $var(carr_id) = $dbr(rf=>[0,1]);
        $var(caller) = $dbr(rf=>[0,2]);
        $var(callee) = $dbr(rf=>[0,3]);
        $var(src_ip) = $dbr(rf=>[0,4]);
        $var(start_time) = $dbr(rf=>[0,5]);

        # Get PDD and user_agent from Redis
        redis_cmd("redis", "GET voip:pdd:$ci", "r_pdd");
        $var(pdd) = $redis(r_pdd=>value);
        if ($var(pdd) == $null) { $var(pdd) = 0; }

        redis_cmd("redis", "GET voip:ua:$ci", "r_ua");
        $var(user_agent) = $redis(r_ua=>value);
        if ($var(user_agent) == $null) { $var(user_agent) = $avp(user_agent); }
        if ($var(user_agent) == $null) { $var(user_agent) = "Unknown"; }

        redis_cmd("redis", "GET voip:codecs:$ci", "r_offered");
        $var(codecs_offered) = $redis(r_offered=>value);
        if ($var(codecs_offered) == $null) { $var(codecs_offered) = ""; }

        # Note: sqlops returns datetime as Unix timestamps, so use FROM_UNIXTIME()
        sql_query("voipdb", "INSERT INTO cdrs (uuid, call_id, customer_id, carrier_id, source_ip, caller, caller_original, callee, callee_original, start_time, end_time, duration, pdd, sip_code, sip_reason, hangup_cause, user_agent, codecs_offered) VALUES (UUID(), '$ci', $var(cust_id), $var(carr_id), '$var(src_ip)', '$var(caller)', NULLIF('$avp(caller_original)', '<null>'), '$var(callee)', NULLIF('$avp(callee_original)', '<null>'), FROM_UNIXTIME($var(start_time)), NOW(3), 0, $var(pdd), $T_reply_code, '$T_reply_reason', 'failed', '$var(user_agent)', '$var(codecs_offered)')");

        # Delete from active_calls
        sql_query("voipdb", "DELETE FROM active_calls WHERE call_id = '$ci'");

        # Decrement counters
        $var(calls_key) = "voip:calls:" + $var(cust_id);
        redis_cmd("redis", "DECR $var(calls_key)", "r");

        if ($var(carr_id) != $null) {
            $var(carrier_calls_key) = "voip:carrier_calls:" + $var(carr_id);
            redis_cmd("redis", "DECR $var(carrier_calls_key)", "r");
        }

        # Clean up Redis keys for this call (including trace flag)
        redis_cmd("redis", "DEL voip:pdd:$ci voip:codec:$ci voip:ua:$ci voip:codecs:$ci voip:trace:$ci", "r_del");
    }
}

# Dialog events callback
event_route[dialog:end] {
    xlog("L_DBG", "DIALOG - End for $ci\n");
}

# Kamailio KEMI framework callback (required for dialog module)
